---
icon: pen-to-square
date: 2024-03-26 12:30:00
category:
  - 篇章2
tag:
  -  防抖 节流 vite和webpack import和require
star: true
---

# 篇章2

## 防抖 节流

#### 防抖： 延迟一定时间执行某一方法，如果重新触发时间重置

#### 节流： 是规定时间内多次触发方法只执行一次

#### 区别: 一个是立即执行规定时间内不重复执行，一个是规定时间内只执行一次，其实区别可以不用回答，介绍防抖和节流就包含了区别

```js
  // 防抖
  function debounce(func,time){
    let timer = null
    return function(..args){
      clearInterval(timer)
      timer = setTimeout(() => {
        func.apply(this,args)
      }, time);
    }
  }
```

```js
  // 节流
  function throttle (func,time){
    let timer = null
    return function(..args){
      if(timer) return
      timer =setTimeout(()=>{
        func.apply(this,time)
      },time)
      timer = null
    }
  }
```
## 深拷贝
- 使用json 序列号和反序列化
  ```js
  const obj = {arr:[1,2] }
  const clone = Json.parse(Json.stringify(obj))
  ```
- 使用递归完成深拷贝
  这种方式通过递归遍历原始对象，并对该对象的属性进行逐一深拷贝，以创建一个原对象独立副本
  ```js
  function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    const clonedObj = Array.isArray(obj) ? [] : {};

    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        clonedObj[key] = deepClone(obj[key]);
      }
    }

    return clonedObj;
  }
  const obj = { a: 1, b: { c: 2 } };
  const deepClonedObj = deepClone(obj);
  deepClonedObj.b.c = 3;
  console.log(obj);            // { a: 1, b: { c: 2 } }
  console.log(deepClonedObj);  // { a: 1, b: { c: 3 } }
  ```
- 第三方库 lodash 库中的 _.cloneDeep 方法
```js
  const _ = require('lodash');
  const obj = { a: 1, b: { c: 2 } };
  const deepClonedObj = _.cloneDeep(obj);
  deepClonedObj.b.c = 3;

  console.log(obj);            // { a: 1, b: { c: 2 } }
  console.log(deepClonedObj);  // { a: 1, b: { c: 3 } }

```

## 跨越
  #### 浏览器对于javascript的同源策略的限制
 协议 域名 端口号 不一致
 解决方案：
  - Jsonp 是利用\<script>标签不受同源策略约束的特点通过动态创建并插入\<script>标签来实现跨域请求
  - nginx反向代理
  - cors 服务端设置响应头
  - 服务端配置代理服务器实现跨域
  - vue proxy配置代理跨域
  
## 说说对于vite和webpack的理解
  - webpack 和 vite都是很好的打包工具,对于webpack,在大型项目中构建比较蛮,因为它需要对文件执行多次扫描和转译,从而衍生了vite,vite是以开发模式极速构建著称,它利用了ES模块
    特性,只构建正在编译的模块,而不是项目,真正做到了按需引入
  - webpack 目前插件生态比较丰富,对于vite插件相对较少,同时对于项目的话个人认为webpack适合大型项目,vite适合中小型项目

## 如何把webpack迁移到vite
引用[webpack迁移到vite](https://blog.csdn.net/x550392236/article/details/1337529323)
##  import 和 require的区别
  - 首先是标准不同 import/export 是ES6标准, require/module.exports 是CommonJS的标准
  - 其次是执行过程 import是编译时执行异步加载,require是运行时才执行即同步加载
  - import会 提升到文件的顶部
  - require的性能会相对稍低于import
