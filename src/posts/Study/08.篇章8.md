---
icon: pen-to-square
date: 2024-4-7 12:00:00
category:
  - 篇章4
tag:
  - 拓展
star: true
---

# 篇章8

## 从 url 输入地址到最终网页渲染，中间发生了什么 / 浏览器从输入到渲染的过程经历哪些过
:::info
  - DNS解析（查询）：将域名地址解析成ip地址
    - 浏览器DNS解析
    - 计算机DNS解析
    - 路由器DNS解析
    - 网络运行商DNS解析
    - 递归查询
  - TCP链接： TCP三次握手
      - 客户端发送服务端：我准备好了，请你准备一下
      - 服务端发送客户端：我也准备好了，请你确认一下
      - 客户端发送服务端： 确认完毕
  - 发送请求
      - 将请求报文发送过去
  - 返回响应
      - 将响应报文发送过来
  - 渲染页面
      - 遇到HTML，调用HTML解析器，解析成DOM树
      - 遇到CSS，调用CSS解析器，解析成CSSOM树
      - 遇到JS,调用JS解析器（JS引擎），解析JS代码
        - 可能要修改元素节点，重新调用HTML解析器，解析成新的DOM树
        - 可能要修改样式节点，重新调用CSS解析器，解析成新的CSSOM树
      - 将DOM + CSSOM  = render树（渲染树）
      - layout布局：计算元素位置和大小信息
      render渲染：将颜色渲染上去
  - 断开链接：TCP四次挥手
      - 断开请求链接2次
      - 断开响应链接2次

      - 客户端发送服务端：请求数据发送完毕，可以断开了
      - 服务端发送客户端：请求数据接收完毕，可以断开了
      - 服务端发送客户端：响应数据发送完毕，可以断开了
      - 客户端发送服务端：响应数据接收完毕，可以断开了
:::
 <!-- #### 详细步骤如下
  - DNS查询服务器IP
  - TCP 三次握手
  - TLS 协商
  - 发送GET请求HTML文件
  - 将HTML内容构建DOM树
  - 将CSS内容构建CSSOM树
  - 将DOM树和CSSOM树合成渲染树
  - 根据渲染树进行页面元素布局
  - 绘制到页面 -->

## Localstorage / Sessionstorage / Cookie
:::info Localstorage / Sessionstorage / Cookie 区别
- 存储大小
    - cookie数据大小不能超过4k ；
    - sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大；
- 有效时间
    -  cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭；
    -  sessionStorage 数据在当前浏览器窗口关闭后自动删除；
    - localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
- 数据与服务器之间的交互方式
    - cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端；
    - sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存；
- 数据共享与独立性
  - cookie 对同一域名下的网站可以共享cookie数据
  - sessionStorage 数据在不同的窗口或标签页之前不共享
  - localStorage 在整个浏览器实例中共享数据，无论打开多少个窗口或标签页，都可以访问到相同localStorage数据

- 使用场景
  - cookie适用于需要在客户端与服务端之前传递小量数据的场景；如身份验证和会话管理
  - sessionStorage适用于同一浏览器窗口或者标签页中存储临时数据的场景
  - localStorage 适用于需要在客户端长期存储大量数据的场景
<!-- - 作用域
      -  localStorage的作用域限制在文档源的；
      -  localStorage同源的文档之间可以相互访问和修改相同名称的数据；
      -  localStorage受浏览器厂商的限制，chrome下存储的数据，360浏览器下不可访问； 会得到‘Invalid Date’；
      -  sessionStorage在localStorage的同源策略基础之上，还有更严格的限制：
          - 他还被限制在窗口中，意思是同一个窗口或标签页的不同页面之间可以共享sessionStorage；
          -  但是不同的窗口或标签页之间不能共享sessionStorage，即便他们是同一个页面地址；
          -  这里的窗口是顶级窗口，如果里面有多个iframe，他们之间共享sessionStorage； -->
:::
## 浏览器的宏任务与微任务是什么
::: info 宏任务与微任务
  微任务优先于宏任务
 - 宏任务
    - 宏任务是由浏览器发起的任务，通常包括整体代码、setTimeout、setInterval、I/O 操作等。
    - 宏任务会被添加到宏任务队列中，等待浏览器的执行
    - 宏任务执行完毕后，会清空微任务队列
 - 微任务
    - 微任务是在宏任务执行完毕后立即执行的任务。微任务通常包括 Promise 的回调、MutationObserver 等
    - 微任务队列有自己的执行时机，在每个宏任务执行完毕后，会检查微任务队列并执行其中的所有任务。
:::
## 事件循环 EventLoop
:::info 事件循环(EventLoop)的理解
  - 事件循环是JavaScript中一种用于处理异步操作的机制；它是JavaScript单线程执行模型的核心部分，负责协调和处理任务的执行顺序
  javaScript是一门单线程语言，意味着它只有一个主程序来执行代码，然后实际开发中，我们经常会遇到需要处理异步任务的情况。比如网络请求、定时器和事件处理等，为了不阻塞主线程执行，javaScript引入了事件循环机制

  - 事件循环的基本原理如下
      - 执行栈： js代码执行过程中会使用一个执行栈来记录函数调用顺序和位置，当执行一个函数时，它会被推入执行栈，当函数执行完成，会从执行栈中弹出
      - 任务队列： 异步任务完成时，会被放入任务队列中等待执行，常见的异步任务包括定时器回调函数、网络请求的回调函数、事件处理函数等
      - 事件循环：事件循环是一个持续运行的过程，它不断地检查执行栈和任务队列状态，并根据一定的规则将任务队列推入执行栈中执行
:::

## 为什么要减少DOM操作中的重绘重排
:::info 减少重绘重排（优化前端与服务器之间通讯性能）

基础概念
 - DOM是JS操作HTML的接口，属于前端入门知识，同时也是前端开发的核心基础和重要基石
 - 因为前端大部分功能都是需要通过dom来实现的，比如 动态渲染列表、用户交互响应、表格表单处理、数据可视化以及复杂的动画和过渡效果

前端与服务器之前性能问题如何产生的
 - 浏览器包括渲染引擎（浏览器内核）和JS引擎且它们都是单线程引擎，单线程有很大优势，比如开发方面避免了多线程的死锁、竞争等问题；劣势是失去了并发能力
 - 浏览器为了避免两个引擎同时修改页面而造成渲染的结果不一致情况，会让这两个引擎具有互斥性，也就是说在某个时刻这两个引擎只有一个在运行，另一个会被阻塞
 - 浏览器的这种互斥性机制是为了确保页面在渲染和执行js代码时的一致性和稳定性。举个例子（假设一个页面中有一个动态更新元素，这个元素内容是通过js定期修改的同时浏览器也在不断的重新渲染这个页面以反映其他元素变化）如果没有引擎互斥机制就有可能出现js引擎正在修改这个元素内容的同时，渲染引擎也开始重新渲染页面，导致渲染结果不够准确或者比较混乱。
 - 但是由于浏览器引擎的互斥性当js引擎正在修改元素内容时，渲染引擎会被阻塞，直到js引擎完成修改随后渲染引擎才会重新渲染页面，确保页面内容的一致性和准确性
 - 从js引擎切换到渲染引擎执行对应操作然后再切换为js引擎继续执行这就带来了性能损耗；单次性能损耗是非常少的，但是如果频繁的大量切换就会产生性能问题，既然产生了性能问题？那该如何解决，答案就是重绘重排， 因为重绘重排在渲染过程是最耗时的

什么是重绘重排？
 - 浏览器渲染页面时会将HTML和CSS解析成DOM树和CSS规则树，然后再合并排布最后绘制成我们可见的页面
 - 如果在操作DOM时需要重新计算几何属性，比如宽度、高度、位置等就会引起渲染引擎重新计算，从而影响元素的排布操作这种操作称为重排
 - 重排之后浏览器会根据新的样式规则绘制元素而绘制的过程称为重绘
 - 重排的发生会伴随重绘，但重绘不一定需要重排，比如修改背景图片、修改字体颜色等
 - 因此在优化DOM操作时我们尽量避免触发重排，特别是那些影响其他元素排布的情况

:::

## get和post
:::info get和post
  浅易理解get是从服务端获取数据，post是像服务端发送数据

  get和post方法的区别
  - 1：get和post都是http请求的方法，而http又是基于tcp/ip的应用层通讯协议，所以本质上来说get和post请求是没有区别的，都是tcp链接，他们能做的事情都是一样的，换言之get能做的事情post也可以做，反之亦可
  - 2： http提供的这两种方法也是在特定情况下区分应用
    - 第一 在参数位置方面 get请求的参数是放在url里面的，而post请求参数是放在请求体里面的，当然post请求参数也可以放置在url中，也就意味着get请求参数可以在浏览器地址栏中看到，而post请求的参数不会
    - 第二 在参数长度方面 get请求参数由于由于是在url里面，所以会受到浏览器长度的限制，浏览器的不同长度的数值也不同；而post请求则没有这方面限制，因为请求体的大小理论上是可以非常大的
    - 第三 浏览器缓存方面 get请求可以被浏览器缓存而post请求不能够被缓存，这意味着在多次发起相同get请求时浏览器可能会直接返回缓存的结果，而post请求每次都会与服务器交互
    - 第四 浏览器访问方面 get请求可以通过浏览器直接访问 支持刷新后退，而post请求是不能够被浏览器直接访问的，刷新后数据会重新发送
    - 第五 参数安全性方面 get请求参数可见且可能被缓存因此其安全性相对较低，而post请求参数隐藏在请求体中且不会被缓存因此安全性更高一些
    - 第六 在RESTful架构中 在该架构中get扮演的获取数据的角色，而post扮演的添加数据的角色，所以get对数据是无害的不会对数据资源造成影响，而post使用不当有可能对原有数据源造成伤害



:::
## 说说网络错误码有哪些？ 分别代表什么意思
  #### 网络错误码：以下前缀开发头代表不同的错误
  - 1 开头表示消息
  - 2 开头 表示成功
  - 3 表示重定向
  - 4 表示客户端错误
  - 5 表示服务器错误

  ##### 1XX段：表示请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息
  常见的有：

  - 100(客户端继续发送请求，这是临时响应)
  - 101(服务器根据客户请求切换协议)

  ##### 2xx段： 表示请求已成功被服务器接收、理解、并接受
  常见的有：

  - 200（成功）： 请求已成功，并且返回所希望的响应头和数据体
  - 201 (已创建): 请求成功并且服务器创建了新的资源
  - 202 （已创建）： 服务器已接收请求，但是尚未处理完成
  - 203（非授权信息）:  服务器已成功处理请求,但返回的信息可能来自另一来源
  - 204(无内容)： 服务器成功处理请求，但无返回内容
  - 205(重置内容)： 服务器成功处理请求，但没有任何返回内容
  - 206(部分内容)： 表示服务器成功处理了部分请求，通常在断电续传或者分块下载使用

  ##### 3xx段： 表示完成请求，需要进一步操作。
  常见的有：

  - 300（多种选择）：针对请求，服务器可执行多种操作
  - 301(永久移动)： 请求的页面已永久移动到新位置
  - 302(临时移动): 服务器目前从不同位置的页面响应请求
  - 303(查看其它位置)： 请求者应对不同的位置单独使用get请求来检索响应
  - 304(协商缓存)： 服务器通过状态304可以告诉客户端请求资源成功
  - 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
  - 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

  ##### 4xx段： 表示服务器无法处理请求，客户端错误
  常见的有：

  - 400（错误请求）： 服务器不理解请求的语法
  - 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  - 403（禁止）： 服务器拒绝请求
  - 404（未找到）： 请求的资源不存在
  - 405（方法禁用）： 禁用请求中指定的方法
  - 406（不接受）： 无法使用请求的内容特性响应请求的网页
  - 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
  - 408（请求超时）： 服务器等候请求时发生超时

  ##### 5xx段： 表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生
  常见的有：

  - 500（服务器内部错误）：服务器遇到错误，无法完成请求
  - 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
  - 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
  - 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
  - 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
  - 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

## 如何解决页面刷新丢失数据的问题？
  - 通过本地储存解决 localStorage 或 sessionStorage 存储
  - 或通过插件 vuex-persistedstate 解决

## 单点登录
:::info 单点登录
  多系统，单一位置登录，实现多系统同时登录的一种技术 （前后端分离的 session id 或token保存在localStorage中）
- Cookie+ Session。
  - 用户登录后，认证服务器会将用户信息存储在Session中，并生成一个Session ID。
  - 这个Session ID会存储在Cookie中返回给用户。当用户访问其他应用系统时，系统会检查Cookie中的Session ID。
  - 认证服务器通过这个ID来判断用户是否已经登录，如果已登录，则返回一个新的Session ID给应用系统；否则，需要用户重新登录。
- Token
  - 用户登录后，认证服务器会生成一个Token，并将其存储在共享的存储（如Redis、数据库等）中。
  - 然后，这个Token会返回给用户。
  - 当用户访问其他应用系统时，系统会向认证服务器发送请求，并带上这个Token。
  - 认证服务器通过Token来验证用户是否已登录，如果已登录，则返回一个新的Token给应用系统；否则，需要用户重新登录
- LocalStorage跨域。
  - 在前后端分离的场景下，可以将Session ID或Token保存到浏览器的LocalStorage中。
  - 前端在每次发送请求时，可以将LocalStorage中的数据传递给服务端。
  - 这样，单点登录可以在前端实现，并允许Session ID或Token在多个域下共享。
:::
## SSR实现原理
  vue.js的ssR是一种在服务器上预渲染Vue.js应用程序的技术。
  - 服务器接收请求：当服务器接收一个请求时，它会创建一个新的Vue实例。
  - 创建渲染器：使用vue-server-renderer包创建一个渲染器。
  - 渲染页面：服务器使用渲染器将Vue实例渲染为Html字符串。
  - 发送响应：服务器将渲染后的Html字符串作为响应发送给客户端。
  - 客户端接收响应：客户端接收到服务器的响应后，将HTML字符串解析为DOM并显示给用户。
  - 激活(Hydration): Vue在客户端创建一个新的Vue实例，将其挂载到服务器收到的Dom上

## SSR渲染流程是什么样？
  - 客户端发送URL请求到服务端
  - 服务端查询数据库
  - 拿到数据,组合好页面
  - 服务端返回整个DOM结构给客户端
## diff算法
:::info diff算法概念
- Vue和React都是基于vdom的前端框架，组件渲染会返回vdom，渲染器再把vdom通过增删改的api同步到dom，
- 当再次渲染的时候，会产生新的vdom，渲染器会对比两颗vdom树，对有差异部分通过增删改的api更新到dom
- 这里对比两颗vdom树，找到有差异部分的算法，就叫做diff算法
:::

:::info 简单diff算法
  - diff算法的目的是根据key复用dom节点，通过移动节点而不是创建节点来减少dom操作
  - 对于每个新的vnode，在旧的vnode中根据key查找一下，如果没查找到，那就新增dom节点，如果查找到了，那就可以复用
  - 复用的话要不要移动要判断下下标，如果下标在lastIndex之后，就不需要移动，因为本来就在后面，反之就需要移动
  - 最后，把旧的vnode中在新vnode中没有的节点从dom树中删除
:::

:::info 双端diff算法  vue2使用的
  - 双端diff 是头尾指针向中间移动的同时，对比头头、尾尾、头尾、尾头是否可以复用，如果可以的话就移动对应dom节点
  - 如果头尾没找到可复用节点就遍历vnode数组来查找，然后移动对应下标的节点到头部
  - 最后还剩下旧的vnode就批量删除，剩下的vnode就批量新增
:::


:::info 快速diff算法  vue3
  - 在vue2双端diff的基础上增加了最长递增子序列的逻辑
  - 整体核心思路：复用，能不动就不动，能少移动就少移动，直接创建或者直接删除。
   步骤
     - 针对新旧子节点的前置节点、后置节点进行预处理
     - 预处理完毕，判断是否有节点需要新增/卸载
     - 如果不存在节点需要新增/卸载，判断是否有节点需要进行移动操作
     - 如果存在需要移动的节点情况，即moved为true
:::

[引文](https://juejin.cn/post/7114177684434845727?searchId=202404071153522975C2613D0C207BD41C)


<!-- diff算法主要采用深度优先算法，逐层进行比较，具体实现如下
  - 首先会有两个虚拟DOM树，分为新的子节点集合，旧子节点集合
  - 同时会有4个索引分别指向，新子节点的首尾，旧的子节点首尾4个（这里以oldS,oldE,newS,newE）代表
  - 比较的话 就是oldS和oldE 分别对newS、newE进行比较就有四种情况了

  ####相等情况分为4种
   - oldS（旧节点的头）和newS （新节点的头）相等，那么oldS 和 newS 分别索引+1
   - oldS（旧节点的头）和newE （新节点的尾）相等，那么就是oldS +1 然后newE -1
   - oldE（旧节点的尾）和newS （新节点的尾）相等，那么oldE 和 newE 分别索引 +1
   - oldE（旧节点的尾）和newS （新节点的头）相等，那么就是oldE -1 然后 newS +1

最后会出现一种情况，就是如果存在不相等的节点的时候
会有两种结果
  - new的子节点集合大于  旧的子节点集合，添加新的子节点
  - 旧的节点集合大于新的节点集合，那么就会真实DOM中（不是在旧节点）删除多余的子节点 -->
## 后台系统中权限是实现到什么等级? 具体怎么实现的
  #### 目前大多数是实现到按钮级,实现的方法是通过自定义指令
  ##### 具体流程如下:
  - 从服务器获取一个对象,对象里包含了所有按钮的权限,
  - 给按钮添加自定义指令,并且为每个按钮传递不同参数
  - 通过自定义指令的bind生命周期 设置按钮的display 控制是否展示按钮或者直接删除元素




## 图片预加载 图片懒加载
::: info 图片预加载 图片懒加载
图片预加载： 顾名思义，图片预加载就是在网页全部加载之前， 提前加载图片。 当用户需要查看时可直接从本地缓存中渲染， 以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，这样浏览者可能以为图片预览慢而没兴趣浏览，把网页关掉，这时，就需要图片预加载。 当然这种做法实际上牺牲了服务器的性能换取了更好的用户体验。

图片懒加载（缓载 ）： 延迟加载图片或符合某些条件时才加载某些图片。这样做的好处是减少不必要的访问数据库或延迟访问数据库的次数，因为每次访问数据库都是比较耗时的即只有真正使用该对象的数据时才会创建。 懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

:::
## 图片预加载
常用的是new Image();，设置其src来实现预载，再使用onload方法回调预载完成事件。
引用[骨架屏](https://blog.csdn.net/weixin_42530606/article/details/129089128)
## 前端图片懒加载的原理
tips：核心原理是通过 判断图片元素是否显示在视图中，如果显示在视图中即显示图片。
 - 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟，如果用户在加载前就离开了页面，那么就不会加载。 

 - 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。

 - 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片
  #### 具体步骤如下：
  - 声明img标签但是src属性为空，我们可以另外设置一个自定义属性data-src用来赋值图片url
  - 然后就是监听scroll事件，同时scroll事件可以加上 节流，减少资源浪费
  - 判断当前图片是否有在可视范围内，判断方法有多种，例如： offsetTop+offsetHeight > scrollTop或者
    getBoundingClientRect判断 top和left小于视窗高度(clientHeight)
  - 如果是的情况下我们获取这个img元素的data-src然后把属性赋值src即可
## 如何让你在数组中查找元素你会如何实现
 如果是基础类型的数组 考虑使用 indexOf进行查找
 如果是对象数组 则使用findIndex进行查找

## 浏览器用过哪些缓存
 - 1、http缓存是基于HTTP协议的浏览器文件级缓存机制。
 - 2、websql这种方式只有较新的chrome浏览器支持，并以一个独立规范形式出现
 - 3、indexDB是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API
 - 4、Cookie一般网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）
 - 5、Localstorage html5的一种新的本地缓存方案，目前用的比较多，一般用来存储ajax返回的数据，加快下次页面打开时的渲染速度
 - 6、Sessionstorage和localstorage类似，但是浏览器关闭则会全部删除，api和localstorage相同，实际项目中使用较少。
 - 7、application cache是将大部分图片资源、js、css等静态资源放在manifest文件配置中
 - 8、cacheStorage是在ServiceWorker的规范中定义的，可以保存每个serverWorker申明的cache对象
 - 9、flash缓存这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能

## 垃圾回收机制
:::info 垃圾回收机制
js代码在运行时，需要分配内存空间储存变量和值，当这个变量不再引用时，需要对其占用的内存进行回收。
如果不及时清理，会造成卡顿，内存溢出，这就是需要垃圾回收机制的存在。
在 V8 中，会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象
垃圾回收机制分为
主垃圾回收机制：负责清理生存时间比较长的数据
副垃圾回收机制：负责清理存在时间比较短的数据

:::

## seo优化有了解过吗
::: info seo(搜索引擎)优化
  它是一种通过调整网站的内容、结构、外部链接等方面的优化手段，来提高网站在搜索引擎自然/免费搜索结果中的排名和可见度的过程
  TDK是Title(标题)、Description（描述）和 Keywords（关键词）的缩写，是网站SEO的关键
  [引文](https://juejin.cn/post/7349752708385816630?searchId=20240407114003C23B016413FFD78EBD30)
:::
## 堆和栈
  - 堆（堆内存）
      用于动态分配内区的区域，用于存储引用类型，如对象和数组
      （在堆中分配的内存不会自动释放，需要通过垃圾回收机制来回收不再使用的内存。堆的大小通常比栈大，并且可以动态增长和收缩。）
  - 栈
      同于管理函数执行上下文和存储基本类型值的一种数据结构
        （每当执行一个函数时，都会在栈中创建一个新的执行上下文，包括函数的参数、局部变量和函数的返回地址。当函数执行完成后，
        对应的执行上下文会被销毁，栈会自动释放相关的内存。栈的大小通常比较小且固定，内存分配由系统自动管理。）

  区别
    - 存储内容：堆用于存储引用类型的数据，如对象和数组；栈用于存储基本类型的数据，如布尔值、数值和字符串，以及函数执行的上下文。
    - 分配方式：堆通过动态分配内存来存储数据；栈通过在执行上下文中的栈帧上分配固定大小的内存来存储数据。
    - 大小和生长性：堆的大小通常比栈大，可以动态增长和收缩；栈的大小通常比较小且固定，由系统自动管理。
    - 管理方式：堆的内存管理需要使用垃圾回收机制来回收不再使用的内存；栈的内存管理由系统自动处理，通过栈指针的移动来分配和释放内存。
    - 生命周期：堆中分配的内存不会自动释放，需要通过垃圾回收来回收内存；栈中的内存由系统自动管理，在函数执行完成后自动释放。


##  什么是柯里化函数，你对柯里化了解多少？
  #### 柯里化： 柯里化是一个高阶函数,它可以将多个形参的函数转成单一的形参的函数

  #### 代码实现:其实柯里化函数的核心点主要在args.length和fn.length的判断，当传入的参数个小小于原始函数的参数个数，则继续柯里化
```js
  function curry(fn, ...args) {
    return function (...params) {
        const _args = [...args, ...params];
        if (_args.length >= fn.length) {
        	return fn(..._args)
        } else {
        	return curry.call(this, fn, ..._args)
        }
    }
  }
```

## 虚拟dom
 虚拟dom是用来表现真实dom结果的javaScript对象树，是构建在浏览器真实dom上的抽象层，虚拟dom是可以直接在内存中操作的，可以通过diff算法来对比新旧dom 差异，将最终变化应用到真实dom上


