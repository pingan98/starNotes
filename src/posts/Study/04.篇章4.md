---
icon: pen-to-square
date: 2024-03-28 08:00:00
category:
  - 篇章4
tag:
  - 基础 优化
star: true
---

# 篇章4

## SSR实现原理
vue.js的ssR是一种在服务器上预渲染Vue.js应用程序的技术。
  - 服务器接收请求：当服务器接收一个请求时，它会创建一个新的Vue实例。
  - 创建渲染器：使用vue-server-renderer包创建一个渲染器。
  - 渲染页面：服务器使用渲染器将Vue实例渲染为Html字符串。
  - 发送响应：服务器将渲染后的Html字符串作为响应发送给客户端。
  - 客户端接收响应：客户端接收到服务器的响应后，将HTML字符串解析为DOM并显示给用户。
  - 激活(Hydration): Vue在客户端创建一个新的Vue实例，将其挂载到服务器收到的Dom上

## 1:SSR渲染流程是什么样？
  - 客户端发送URL请求到服务端
  - 服务端查询数据库
  - 拿到数据,组合好页面
  - 服务端返回整个DOM结构给客户端

## 2:浏览器从输入到渲染的过程经历哪些过
 #### 详细步骤如下
  - DNS查询服务器IP
  - TCP 三次握手
  - TLS 协商
  - 发送GET请求HTML文件
  - 将HTML内容构建DOM树
  - 将CSS内容构建CSSOM树
  - 将DOM树和CSSOM树合成渲染树
  - 根据渲染树进行页面元素布局
  - 绘制到页面



## 3: 说说网络错误码有哪些？ 分别代表什么意思
  #### 网络错误码：以下前缀开发头代表不同的错误
  - 1 开头表示消息
  - 2 开头 表示成功
  - 3 表示重定向
  - 4 表示客户端错误
  - 4 表示服务器错误

  ##### 1XX段：表示请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息
  常见的有：

  - 100(客户端继续发送请求，这是临时响应)
  - 101(服务器根据客户请求切换协议)

  ##### 2xx段： 表示请求已成功被服务器接收、理解、并接受
  常见的有：

  - 200（成功）： 请求已成功，并且返回所希望的响应头和数据体
  - 201 (已创建): 请求成功并且服务器创建了新的资源
  - 202 （已创建）： 服务器已接收请求，但是尚未处理完成
  - 203（非授权信息）:  服务器已成功处理请求,但返回的信息可能来自另一来源
  - 204(无内容)： 服务器成功处理请求，但无返回内容
  - 205(重置内容)： 服务器成功处理请求，但没有任何返回内容
  - 206(部分内容)： 表示服务器成功处理了部分请求，通常在断电续传或者分块下载使用

  ##### 3xx段： 表示完成请求，需要进一步操作。
  常见的有：

  - 300（多种选择）：针对请求，服务器可执行多种操作
  - 301(永久移动)： 请求的页面已永久移动到新位置
  - 302(临时移动): 服务器目前从不同位置的页面响应请求
  - 303(查看其它位置)： 请求者应对不同的位置单独使用get请求来检索响应
  - 304(协商缓存)： 服务器通过状态304可以告诉客户端请求资源成功
  - 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
  - 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

  ##### 4xx段： 表示服务器无法处理请求，客户端错误
  常见的有：

  - 400（错误请求）： 服务器不理解请求的语法
  - 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  - 403（禁止）： 服务器拒绝请求
  - 404（未找到）： 请求的资源不存在
  - 405（方法禁用）： 禁用请求中指定的方法
  - 406（不接受）： 无法使用请求的内容特性响应请求的网页
  - 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
  - 408（请求超时）： 服务器等候请求时发生超时

  ##### 5xx段： 表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生
  常见的有：

  - 500（服务器内部错误）：服务器遇到错误，无法完成请求
  - 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
  - 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
  - 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
  - 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
  - 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

## 4:如何解决页面刷新丢失数据的问题？
  - 通过本地储存解决 localStorage 或 sessionStorage 存储
  - 或通过插件 vuex-persistedstate 解决

## 4: 后台系统中权限是实现到什么等级? 具体怎么实现的
  #### 目前大多数是实现到按钮级,实现的方法是通过自定义指令
  ##### 具体流程如下:
  - 从服务器获取一个对象,对象里包含了所有按钮的权限,
  - 给按钮添加自定义指令,并且为每个按钮传递不同参数
  - 通过自定义指令的bind生命周期 设置按钮的display 控制是否展示按钮或者直接删除元素


## 6: for in 循环对象的时候是有序的吗
  #### 无序的， for in 循环的时候，不要依靠顺序去进行判断


## 7: 前端做过哪些优化
  - 一些第三方库通过CDN方式引入
  - 使用iconfont代替图片图标
  - 图片懒加载 路由懒加载
  - 代码层面例如防抖节流 频繁切换的场景使用v-show替换v-if
  - 利用webpack-boundle-analyzer 分析打包后文件大小，进行优化

## 8: 前端图片懒加载的原理
tips：核心原理是通过 判断图片元素是否显示在视图中，如果显示在视图中即显示图片。
  #### 具体步骤如下：
  - 声明img标签但是src属性为空，我们可以另外设置一个自定义属性data-src用来赋值图片url
  - 然后就是监听scroll事件，同时scroll事件可以加上 节流，减少资源浪费
  - 判断当前图片是否有在可视范围内，判断方法有多种，例如： offsetTop+offsetHeight > scrollTop或者     
    getBoundingClientRect判断 top和left小于视窗高度(clientHeight)
  - 如果是的情况下我们获取这个img元素的data-src然后把属性赋值src即可

## 9: 箭头函数和普通函数的区别？
  - 箭头函数没有原型，所以箭头函数没有this
  - 箭头函数this继承外层的第一个普通函数
  - 不能直接修改箭头函数的this指向
  - 箭头函数没有argements
  - 箭头函数只能声明匿名函数（箭头函数可以通过表达式让箭头函数具名），普通函数可以是具名函数也可以是匿名函数

## 箭头函数的this会指向什么
   箭头函数this通常在创建的时候 就已经确定了指向，会指向外层的this

## 以下this会指向什么
  ```js
    const fn = ()=>{
      console.log(this)
    }
    const obj = {
     func: fn
    }
    obj.func()
  ```
  #### this会指向window，因为它声明的使用会指向外层的this
  如果箭头函数改成普通函数
  ```js
    function fn (){
      console.log(this)
    }
    const obj ={
      func: fn
    }
    obj.func()
  ```
  #### 此时还是指向obj函数会根据执行时，谁调用了它而指向谁
  如果箭头函数上加上bin，this会指向什么
  依旧指向window，因为箭头函数不可改变this的指向

## 10：var和let有什么区别
  - var和let 都有变量提升，但是let有一个暂时性死区
  - var 是函数作用域 let是块级作用域
  - var 可以重复声明，而let不行

## 11：ES6 有哪些新的特性
- 类class，extends
- 箭头函数
- let const
- 模板字符串
- 扩展运算符...
- 解构赋值
- import/export
- Promise
- Symbol
- Proxy
- 函数参数默认值


## 13：Json.parse和Json.stringify的实现

  ##### json.stringify() 是将对象或值转换为JSON字符串 ;  json.parse() 解析JSON 字符串，就是把JSON字符串转成对象

  [具体答案：一文彻底弄懂JSON.parse()与JSON.stringify()](https://zhuanlan.zhihu.com/p/638767443)

## 14：如何实现路由懒加载？
  在router 通过回调的方式引入组件就可以实现异步加载
原理： 主要是因为javascript 运行机制、事件循环以及打包工具的配合
  - 当打包工具遇到import的时候会把这些组件当做单独js文件进行打包
  - 页面加载的时候，只有主要boundle会被下载
  - 当用户需要组件的时候，再发起网络请求，请求对应的异步组件
  - 然后进行下载和执行
  - 最后渲染


## 如何让你在数组中查找元素你会如何实现
 如果是基础类型的数组 考虑使用 indexOf进行查找
 如果是对象数组 则使用findIndex进行查找

## call apply bind的区别
   - 传递参数的方式
     call 以参数列表形式传递参数 func.call(context, arg1, arg2, ...);
     apply 以数组形式传递参数 func.call(context, [arg1, arg2, ...]);
     bind 创建表一个新的函数，并以参数列表的形式传递参数，但不会立即执行原函数
          const newFunc = func.bind(context,agr1,agr2,...)
  - 立即执行和返回新函数
    call/apply 立即执行原函数
    bind 不会立即执行原函数，而是返回一个新函数，可以稍后调用
  - 返回值
    call/apply  返回原函数执行结果
            const result = func.call(context, arg1, arg2, ...);
    bind 返回新函数，需要调用这个新函数才能获取结果
            const newFunc = func.call(context, arg1, arg2, ...);
            const result  = newFunc()
  - 使用场景
        call 和 apply 主要用于借用其他对象的方法，或者在一个对象上调用一个函数，同时指定该函数内部的 this 值。
        bind： 主要用于创建一个与原函数拥有相同 this 值的新函数，方便稍后调用。


  - 性能：
        call 和 apply由于立即执行原函数，可能略微更高效，但在大多数情况下性能差异微乎其微。
        bind 创建了一个新的函数，性能可能稍差一些，但同样在大多数情况下不会引起明显的性能问题。

 #### 示例：
 ```js
  const obj = { value: 42 };

  function getValue(arg) {
    console.log(this.value + arg);
  }

  getValue.call(obj, 2);      // 输出: 44
  getValue.apply(obj, [2]);   // 输出: 44

  const boundFunc = getValue.bind(obj, 2);
  boundFunc();                // 输出: 44


 ```

 ## new String('123')和String('123') new String('123')==String('123')吗，typeof判断这两个是什么
    两种定义方式的不同
    1.字符串常量存储在字符串常量池，目的是共享。
    2.字符串非常量值对象存储在堆中。

     不相等
    typeof(new String('123')) 为object typeof('123') string
## indexOf 和 includes有什么区别
  - indexOf是返回下标，如果找到返回对应下标如果没有则返回-1
  - includes返回值是true 和 false
  - indexOf 是严格等于 相当于（===），includes是使用零等值法 0可以等于-0
     特别说明indexOf中NAN永远返回-1，而includes NAN可以是true

## typeof 和instanceof的区别
  - 都是用来判断变量是否为空，或者属于什么数据类型
  - typeof返回的是一个字符串，用来判断是什么数据类型
  - instanceof 返回的是一个布尔值，用来判断一个变量是否属于对象上的实例
  - typeof检测的是简单数据类型， instanceof 检测的是引用数据类型

## 浏览器的宏任务与微任务是什么
  微任务优先于宏任务
 - 宏任务
    宏任务是由浏览器发起的任务，通常包括整体代码、setTimeout、setInterval、I/O 操作等。宏任务会被添加到宏任务队列中，等待浏览器的执行
    宏任务执行完毕后，会清空微任务队列
 - 微任务
    微任务是在宏任务执行完毕后立即执行的任务。微任务通常包括 Promise 的回调、MutationObserver 等
    微任务队列有自己的执行时机，在每个宏任务执行完毕后，会检查微任务队列并执行其中的所有任务。

## 堆和栈
  - 堆（堆内存）
      用于动态分配内区的区域，用于存储引用类型，如对象和数组
      （在堆中分配的内存不会自动释放，需要通过垃圾回收机制来回收不再使用的内存。堆的大小通常比栈大，并且可以动态增长和收缩。）
  - 栈
      同于管理函数执行上下文和存储基本类型值的一种数据结构
        （每当执行一个函数时，都会在栈中创建一个新的执行上下文，包括函数的参数、局部变量和函数的返回地址。当函数执行完成后，
        对应的执行上下文会被销毁，栈会自动释放相关的内存。栈的大小通常比较小且固定，内存分配由系统自动管理。）

  区别
    - 存储内容：堆用于存储引用类型的数据，如对象和数组；栈用于存储基本类型的数据，如布尔值、数值和字符串，以及函数执行的上下文。
    - 分配方式：堆通过动态分配内存来存储数据；栈通过在执行上下文中的栈帧上分配固定大小的内存来存储数据。
    - 大小和生长性：堆的大小通常比栈大，可以动态增长和收缩；栈的大小通常比较小且固定，由系统自动管理。
    - 管理方式：堆的内存管理需要使用垃圾回收机制来回收不再使用的内存；栈的内存管理由系统自动处理，通过栈指针的移动来分配和释放内存。
    - 生命周期：堆中分配的内存不会自动释放，需要通过垃圾回收来回收内存；栈中的内存由系统自动管理，在函数执行完成后自动释放。
## 排序
```js
  // 请将数组排序从小到大
  let array = [7,5,2,27,19,36,21]
  array.sort((a,b) => a - b)
  console.log('排序后的数组',array)
```
## 去重
```js
const newArr = [...new Set(arr)]
const newArr = arr.filter((item,index)=>{ return arr.indexOf(item)=== index})

```
## 扁平化
```js
function flatten(arr) {
  return arr.flat(Infinity);
}
```

## 冒泡排序
  ```js
  const arr = [1,7,9,2,5,3]
  for (let i=0; i<arr.length; i++){
    for(let j=0; j<arr.length-i-1; j++){
      let a = []
      if(arr[j] < arr[j+1]){
        a = arr[j]
        arr[j] = arr[j+1]
        arr[j+1] = a
      }
    }
  }

  ```



##  什么是柯里化函数，你对柯里化了解多少？
  #### 柯里化： 柯里化是一个高阶函数,它可以将多个形参的函数转成单一的形参的函数

  #### 代码实现:其实柯里化函数的核心点主要在args.length和fn.length的判断，当传入的参数个小小于原始函数的参数个数，则继续柯里化
```js
  function curry(fn, ...args) {
    return function (...params) {
        const _args = [...args, ...params];
        if (_args.length >= fn.length) {
        	return fn(..._args)
        } else {
        	return curry.call(this, fn, ..._args)
        }
    }
  }
```

## 虚拟dom
 虚拟dom是用来表现真实dom结果的javaScript对象树，是构建在浏览器真实dom上的抽象层，虚拟dom是可以直接在内存中操作的，可以通过diff算法来对比新旧dom 差异，将最终变化应用到真实dom上
## diff算法原理
diff算法又称虚拟Dom的周界算法，vue的diff算法是通过深度优先、先序遍历的方式进行的，它将前后两个虚拟Dom树进行逐层比较，当找到某一层不一样的节点时，停止下降，然后比较这些节点的子节点，当所有的子节点都完成比较之后，算法会由下至上进行回溯，此过程被称为执行patch操作。在执行patch操作时，Vue对于不同类型的节点的更新方式也不同，对于元素节点可以更新他的属性和子节点；对于文本节点，只能更新它的文本内容；对于每个子节点，如果key值相同，可以进行复用或者重新排序，或者将其他的节点移动到这个位置。

diff算法主要采用深度优先算法，逐层进行比较，具体实现如下
  - 首先会有两个虚拟DOM树，分为新的子节点集合，旧子节点集合
  - 同时会有4个索引分别指向，新子节点的首尾，旧的子节点首尾4个（这里以oldS,oldE,newS,newE）代表
  - 比较的话 就是oldS和oldE 分别对newS、newE进行比较就有四种情况了

  ####相等情况分为4种
   - oldS（旧节点的头）和newS （新节点的头）相等，那么oldS 和 newS 分别索引+1
   - oldS（旧节点的头）和newE （新节点的尾）相等，那么就是oldS +1 然后newE -1
   - oldE（旧节点的尾）和newS （新节点的尾）相等，那么oldE 和 newE 分别索引 +1
   - oldE（旧节点的尾）和newS （新节点的头）相等，那么就是oldE -1 然后 newS +1

最后会出现一种情况，就是如果存在不相等的节点的时候
会有两种结果
  - new的子节点集合大于  旧的子节点集合，添加新的子节点
  - 旧的节点集合大于新的节点集合，那么就会真实DOM中（不是在旧节点）删除多余的子节点

## 浏览器用过哪些缓存
 - 1、http缓存是基于HTTP协议的浏览器文件级缓存机制。
 - 2、websql这种方式只有较新的chrome浏览器支持，并以一个独立规范形式出现
 - 3、indexDB是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API
 - 4、Cookie一般网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）
 - 5、Localstorage html5的一种新的本地缓存方案，目前用的比较多，一般用来存储ajax返回的数据，加快下次页面打开时的渲染速度
 - 6、Sessionstorage和localstorage类似，但是浏览器关闭则会全部删除，api和localstorage相同，实际项目中使用较少。
 - 7、application cache是将大部分图片资源、js、css等静态资源放在manifest文件配置中
 - 8、cacheStorage是在ServiceWorker的规范中定义的，可以保存每个serverWorker申明的cache对象
 - 9、flash缓存这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能

 ### 可针对于前端所用Localstorage / Sessionstorage / Cookie描述相同点和不同点
- （1）存储大小
    cookie数据大小不能超过4k ；
    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大；
- （2）有效时间
        localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
        sessionStorage 数据在当前浏览器窗口关闭后自动删除；
        cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭；
- （3）数据与服务器之间的交互方式
        cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端；
        sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存；
- （4）作用域
        localStorage的作用域限制在文档源的；
        localStorage同源的文档之间可以相互访问和修改相同名称的数据；
        localStorage受浏览器厂商的限制，chrome下存储的数据，360浏览器下不可访问； 会得到‘Invalid Date’；
        sessionStorage在localStorage的同源策略基础之上，还有更严格的限制：
            他还被限制在窗口中，意思是同一个窗口或标签页的不同页面之间可以共享sessionStorage；
            但是不同的窗口或标签页之间不能共享sessionStorage，即便他们是同一个页面地址；
            这里的窗口是顶级窗口，如果里面有多个iframe，他们之间共享sessionStorage；