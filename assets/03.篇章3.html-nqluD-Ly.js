import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as i,c as o,a as e,b as p,d as l,f as a}from"./app-CMqfy9JS.js";const r={},c=a(`<h1 id="篇章3" tabindex="-1"><a class="header-anchor" href="#篇章3"><span>篇章3</span></a></h1><h2 id="_1-讲一讲vue3的生命周期以及它们的作用" tabindex="-1"><a class="header-anchor" href="#_1-讲一讲vue3的生命周期以及它们的作用"><span>1:讲一讲vue3的生命周期以及它们的作用</span></a></h2><h5 id="vue3的生命周期主要是四个阶段-9个钩子分别是" tabindex="-1"><a class="header-anchor" href="#vue3的生命周期主要是四个阶段-9个钩子分别是"><span>vue3的生命周期主要是四个阶段 9个钩子分别是</span></a></h5><ul><li>创建-------在组件创建时执行</li><li>挂载-------DOM被挂载时执行</li><li>更新-------当响应式数据被修改时执行</li><li>销毁-------在元素销毁前执行</li></ul><h6 id="钩子函数分别有" tabindex="-1"><a class="header-anchor" href="#钩子函数分别有"><span>钩子函数分别有</span></a></h6><ul><li>beforeCreate------- 初始化事件以及生命周期,此时data和dom都未创建</li><li>created------- 创建后,此时已经初始化完毕,data可以访问,但是dom元素依然不行</li><li>onBeforeMount ------- 在挂载开始前调用,此时dom元素已经生成,但是未挂载到页面上,可以进行异步操作</li><li>onMounted ------- 组件挂载时调用,此时可以访问dom元素,可以进行异步操作</li><li>onBeforeUpdate ------- 数据更新前调用,这里可以访问更新前的dom,通常用来移除事件监听</li><li>onUpdated ------- 由于数据改变更新dom之后调用,这里可以访问更新后的dom</li><li>onBeforeUnmount ------ 卸载组件之前调用,通常用于清除计时以及事件监听</li><li>onUnmounted ------- 组件卸载之后调用,可以用于清除一些资源占用</li></ul><h6 id="补充vue2生命周期" tabindex="-1"><a class="header-anchor" href="#补充vue2生命周期"><span>补充vue2生命周期</span></a></h6><ul><li>beforeCreate: 创建前,初初始化事件以及生命周期,此时data和dom都未创建</li><li>created:创建后,此时已经初始化完毕,data可以访问,但是dom元素依然不行</li><li>beforeMounted: 挂载前,此时dom元素,data,计算属性等已经生成,但dom未挂载到页面上,可以进行异步操作</li><li>mounted: 挂在后,此时dom元素已经挂载完毕,可以访问dom,可以进行异步操作</li><li>beforeUpdate: 更新前,此时可以获取更新前的dom元素,可以对更新前的状态进行保存</li><li>updated: 更新后,此时页面已经更新完毕,可以访问更新后的dom</li><li>beforeDestroy: 销毁前,组件销毁前调用,通常用来清除计数器,事件监听</li><li>destroyed: 销毁后,此时dom元素已经卸载,可以释放组件用过的资源等操作</li></ul><h2 id="_2-setup什么时候执行" tabindex="-1"><a class="header-anchor" href="#_2-setup什么时候执行"><span>2:setup什么时候执行？</span></a></h2><h4 id="setup-在beforecreate之前执行-在组合式api-composition-api-中-setup-生命周期-取代了beforecreate-和created-两个生命周期" tabindex="-1"><a class="header-anchor" href="#setup-在beforecreate之前执行-在组合式api-composition-api-中-setup-生命周期-取代了beforecreate-和created-两个生命周期"><span>setup 在beforeCreate之前执行,在组合式API(Composition API)中 setup 生命周期 取代了beforeCreate 和created 两个生命周期</span></a></h4><p>Tips： setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地去定义。</p><h2 id="_3-异步请求放在created和mounted哪个合适-create会不会有性能提升" tabindex="-1"><a class="header-anchor" href="#_3-异步请求放在created和mounted哪个合适-create会不会有性能提升"><span>3: 异步请求放在created和mounted哪个合适？create会不会有性能提升？</span></a></h2><p>异步请求 放在created 和 mounted 都是可以的,放在created更快的说法,性能并没有多少提升</p><ul><li>created 和 mounted 两者生命周期执行间隔差距很小,甚至到几微米</li><li>如果说在created 请求数据,请求后需要对数据进行操作,那么就得插入到主线程中,那么我们就需要打断X渲染线程</li><li>除此之外有时候请求后 我们需要对dom进行操作,那么created生命周期还没将dom元素挂载上,此时操作不合适</li><li>另外如果是 服务端渲染(ssr) 是需要放到created里进行异步请求,因为服务端不支持mounted</li></ul><h2 id="_4-怎么看待组合式api-composition-api-和-选项式api-options-api" tabindex="-1"><a class="header-anchor" href="#_4-怎么看待组合式api-composition-api-和-选项式api-options-api"><span>4 怎么看待组合式API (Composition API) 和 选项式API(Options API)</span></a></h2><h4 id="options-api" tabindex="-1"><a class="header-anchor" href="#options-api"><span>Options API</span></a></h4><pre><code>- 配置包括了components, props,data,computed,methods, mounted 等这种方式在结构清晰,易于理解,
在小型项目中比较实用
</code></pre><h4 id="composition-api" tabindex="-1"><a class="header-anchor" href="#composition-api"><span>Composition API</span></a></h4><pre><code>- 通过函数的形式来组织代码语言,运行把相关功能组合在一起,提高代码可维护性和重用性

[vue2] 是选项式API 一个逻辑会散落在文件不同位置(data,props,computed,watch,生命周期钩子)
        导致代码可读性变差,当需要修改某个逻辑时,需要上下来回跳转文件位置

[vue3] 组合式API,可将同一逻辑的内容写在一起,增强看代码的可读性,内聚性,
        其还提供了较为完美的逻辑复用性方案,所有逻辑再setup函数中,使用ref,watch 等函数组织代码
</code></pre><h5 id="例-实现一个todolist" tabindex="-1"><a class="header-anchor" href="#例-实现一个todolist"><span>例:实现一个todoList</span></a></h5><pre><code>在 选项式API中,我们需要首先在data中生命一个list,然后再去methods中声明一个方法,然后再去生命周期中调用

在 组合式API中,我们声明的list 和 方法 都可以放在setup中,同时如果将来复用此功能,只需将这一块复制,
而选项式API 则要到data中寻找,再去methods中寻找方法
</code></pre><h2 id="_5-vue3对比vue2做了哪些改进-defineproperty" tabindex="-1"><a class="header-anchor" href="#_5-vue3对比vue2做了哪些改进-defineproperty"><span>5: vue3对比vue2做了哪些改进？defineProperty</span></a></h2><ul><li>性能优化 vue3采用Proxy 替代了Object.defineProperty 实现响应式,并且使用的静态提升技术, 提高渲染的性能,但是对于proxy有一个缺点,对IE11 不支持</li><li>组合式API 可以更好的复用组件逻辑</li><li>TypeScript支持, vue3 已经完全支持TypeScript</li><li>新的自定义渲染API, vue3对于生命周期组件事件等都需要进行自定义以及控制</li></ul><h2 id="_6-proxy和object-defineproperty的区别" tabindex="-1"><a class="header-anchor" href="#_6-proxy和object-defineproperty的区别"><span>6: Proxy和Object.defineProperty的区别</span></a></h2><ul><li>proxy 性能整体上优于 Object.defineProperty</li><li>支持更多数据类型的劫持(vue2只支持Object,Array; vue3 支持Object,Array,Map,WeakMap,Set,WeakSet)</li><li>支持更多时机来进行依赖收集和触发通知 (vue2 只在get时进行依赖收集, vue3在get/has/iterate时进行依赖收集 ;vue2在set时触发通知,vue3在set/add/delete/clear时触发通知),所以vue2 中的响应式缺陷vue可以实现</li><li>vue3 做到了&quot;精准数据&quot;的数据劫持(vue2会把整个data进行递归数据劫持,而vue3只有在用到某个对象时,才进行数据劫持,所以响应式更快并且占用内存更小)</li><li>vue3依赖收集器更容易维护(vue2监听和操作的是原生数组;vue3 是通过重写的方法实现对数组监控)</li></ul><h2 id="_7-vue3的时候ref为什么要使用-value属性-如果是你有什么办法更好的实现它吗" tabindex="-1"><a class="header-anchor" href="#_7-vue3的时候ref为什么要使用-value属性-如果是你有什么办法更好的实现它吗"><span>7:vue3的时候ref为什么要使用.value属性？ 如果是你有什么办法更好的实现它吗？</span></a></h2><h4 id="value属性-首先我们要知道vue3-是基于proxy-和-reflect-实现响应式数据的-proxy能代理的东西是什么" tabindex="-1"><a class="header-anchor" href="#value属性-首先我们要知道vue3-是基于proxy-和-reflect-实现响应式数据的-proxy能代理的东西是什么"><span>.value属性, 首先我们要知道vue3 是基于proxy 和 reflect 实现响应式数据的，proxy能代理的东西是什么？</span></a></h4><h4 id="答案是-对象-那么就不难理解为什么-ref要-value了" tabindex="-1"><a class="header-anchor" href="#答案是-对象-那么就不难理解为什么-ref要-value了"><span>答案是 对象， 那么就不难理解为什么 ref要.value了</span></a></h4><h5 id="至于更好的实现ref-其实就是-value-访问太麻烦-容易混淆-也有人提出ref-sugar-即-ref语法糖-也就是去除ref-value-如何去除" tabindex="-1"><a class="header-anchor" href="#至于更好的实现ref-其实就是-value-访问太麻烦-容易混淆-也有人提出ref-sugar-即-ref语法糖-也就是去除ref-value-如何去除"><span>至于更好的实现ref, 其实就是.value 访问太麻烦,容易混淆,也有人提出ref sugar 即(ref语法糖),也就是去除ref .value,如何去除?</span></a></h5><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token comment">// 核心就是 对set 和 get 进行操作</span>
  <span class="token function">get</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;value&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> target<span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> target<span class="token punctuation">.</span>value<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="核心内容如下-如果vue-模板编译的时候会自动获取value-所以要判断key-为value的情况下-最后return-target-value-key-则是我们正常再js里面不通过-value-进行访问的逻辑" tabindex="-1"><a class="header-anchor" href="#核心内容如下-如果vue-模板编译的时候会自动获取value-所以要判断key-为value的情况下-最后return-target-value-key-则是我们正常再js里面不通过-value-进行访问的逻辑"><span>核心内容如下,如果vue 模板编译的时候会自动获取value,所以要判断key 为value的情况下,最后return target.value[key] 则是我们正常再js里面不通过 value 进行访问的逻辑</span></a></h4><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token comment">// 核心就是 对set 和 get 进行操作</span>

  <span class="token keyword">function</span> <span class="token function">magicRef</span><span class="token punctuation">(</span><span class="token parameter">initialValue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> reactive <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span>
    <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">proxy</span><span class="token punctuation">(</span>reactive<span class="token punctuation">,</span><span class="token punctuation">{</span>
      <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;value&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span> target<span class="token punctuation">.</span>value
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> target<span class="token punctuation">.</span>value<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;value&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          target<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
          target<span class="token punctuation">.</span>value<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> proxy
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,32),u={id:"引用文章",tabindex:"-1"},d={class:"header-anchor",href:"#引用文章"},v={href:"https://juejin.cn/post/7226540105698771003?searchId=20231002075204FF098F426246DB507E79",target:"_blank",rel:"noopener noreferrer"},h=a('<h2 id="_8-为什么vue中的data必须是一个函数-vue是如何实现data互相不污染" tabindex="-1"><a class="header-anchor" href="#_8-为什么vue中的data必须是一个函数-vue是如何实现data互相不污染"><span>8：为什么vue中的data必须是一个函数？ vue是如何实现data互相不污染</span></a></h2><p>在组件中，vue其实是通过构造函数去new一个组件，当data是一个函数的时候，它会有自己的作用域，而不会去影响其他组件。如果说组件的data不是一个函数，而是一个对象，那么会导致这个data会被放到原型上，此时其它实例就可以访问</p><h2 id="_9-mvvm" tabindex="-1"><a class="header-anchor" href="#_9-mvvm"><span>9：MVVM</span></a></h2><ul><li>MVVM 分别为 Model、View、ViewModel</li><li>Model 代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View 代表UI视图，负责数据的展示</li><li>ViewModel 负责监听Model中数据的改变并且控制视图更新；处理用户交互的操作</li><li>Model和View 并无直接关联，而是通过ViewModel 来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步</li><li>这种模式实现了Model和View数据自动同步，因此开发者只需要专注于数据维护操作即可，而不需要自己操作DOM</li></ul>',4);function k(m,f){const n=t("ExternalLinkIcon");return i(),o("div",null,[c,e("h5",u,[e("a",d,[e("span",null,[e("a",v,[p("引用文章"),l(n)])])])]),h])}const _=s(r,[["render",k],["__file","03.篇章3.html.vue"]]),g=JSON.parse('{"path":"/posts/Study/03.%E7%AF%87%E7%AB%A03.html","title":"篇章3","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-03-27T12:30:00.000Z","category":["篇章3"],"tag":["vue2 vue3"],"star":true,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"1:讲一讲vue3的生命周期以及它们的作用","slug":"_1-讲一讲vue3的生命周期以及它们的作用","link":"#_1-讲一讲vue3的生命周期以及它们的作用","children":[]},{"level":2,"title":"2:setup什么时候执行？","slug":"_2-setup什么时候执行","link":"#_2-setup什么时候执行","children":[]},{"level":2,"title":"3: 异步请求放在created和mounted哪个合适？create会不会有性能提升？","slug":"_3-异步请求放在created和mounted哪个合适-create会不会有性能提升","link":"#_3-异步请求放在created和mounted哪个合适-create会不会有性能提升","children":[]},{"level":2,"title":"4 怎么看待组合式API (Composition API) 和 选项式API(Options API)","slug":"_4-怎么看待组合式api-composition-api-和-选项式api-options-api","link":"#_4-怎么看待组合式api-composition-api-和-选项式api-options-api","children":[]},{"level":2,"title":"5: vue3对比vue2做了哪些改进？defineProperty","slug":"_5-vue3对比vue2做了哪些改进-defineproperty","link":"#_5-vue3对比vue2做了哪些改进-defineproperty","children":[]},{"level":2,"title":"6: Proxy和Object.defineProperty的区别","slug":"_6-proxy和object-defineproperty的区别","link":"#_6-proxy和object-defineproperty的区别","children":[]},{"level":2,"title":"7:vue3的时候ref为什么要使用.value属性？ 如果是你有什么办法更好的实现它吗？","slug":"_7-vue3的时候ref为什么要使用-value属性-如果是你有什么办法更好的实现它吗","link":"#_7-vue3的时候ref为什么要使用-value属性-如果是你有什么办法更好的实现它吗","children":[]},{"level":2,"title":"8：为什么vue中的data必须是一个函数？ vue是如何实现data互相不污染","slug":"_8-为什么vue中的data必须是一个函数-vue是如何实现data互相不污染","link":"#_8-为什么vue中的data必须是一个函数-vue是如何实现data互相不污染","children":[]},{"level":2,"title":"9：MVVM","slug":"_9-mvvm","link":"#_9-mvvm","children":[]}],"git":{"createdTime":1711585352000,"updatedTime":1711963004000,"contributors":[{"name":"chengongtao","email":"chengongtao@unicheers.com","commits":3}]},"readingTime":{"minutes":6.89,"words":2067},"filePathRelative":"posts/Study/03.篇章3.md","localizedDate":"2024年3月27日"}');export{_ as comp,g as data};
