import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as p,c as l,a as n,b as o,d as i,f as s}from"./app-zzOpRjEf.js";const c={},r=s(`<h1 id="篇章4" tabindex="-1"><a class="header-anchor" href="#篇章4"><span>篇章4</span></a></h1><h2 id="for-in-循环对象的时候是有序的吗" tabindex="-1"><a class="header-anchor" href="#for-in-循环对象的时候是有序的吗"><span>for in 循环对象的时候是有序的吗</span></a></h2><h4 id="无序的-for-in-循环的时候-不要依靠顺序去进行判断" tabindex="-1"><a class="header-anchor" href="#无序的-for-in-循环的时候-不要依靠顺序去进行判断"><span>无序的， for in 循环的时候，不要依靠顺序去进行判断</span></a></h4><h2 id="前端做过哪些优化" tabindex="-1"><a class="header-anchor" href="#前端做过哪些优化"><span>前端做过哪些优化</span></a></h2><ul><li>一些第三方库通过CDN方式引入</li><li>使用iconfont代替图片图标</li><li>图片懒加载 路由懒加载</li><li>代码层面例如防抖节流 频繁切换的场景使用v-show替换v-if</li><li>利用webpack-boundle-analyzer 分析打包后文件大小，进行优化</li></ul><h2 id="如何实现路由懒加载" tabindex="-1"><a class="header-anchor" href="#如何实现路由懒加载"><span>如何实现路由懒加载？</span></a></h2><p>在router 通过回调的方式引入组件就可以实现异步加载 原理： 主要是因为javascript 运行机制、事件循环以及打包工具的配合</p><ul><li>当打包工具遇到import的时候会把这些组件当做单独js文件进行打包</li><li>页面加载的时候，只有主要boundle会被下载</li><li>当用户需要组件的时候，再发起网络请求，请求对应的异步组件</li><li>然后进行下载和执行</li><li>最后渲染</li></ul><h2 id="箭头函数和普通函数的区别" tabindex="-1"><a class="header-anchor" href="#箭头函数和普通函数的区别"><span>箭头函数和普通函数的区别？</span></a></h2><ul><li>箭头函数没有原型，所以箭头函数没有this</li><li>箭头函数this继承外层的第一个普通函数</li><li>不能直接修改箭头函数的this指向</li><li>箭头函数没有argements</li><li>箭头函数只能声明匿名函数（箭头函数可以通过表达式让箭头函数具名），普通函数可以是具名函数也可以是匿名函数</li></ul><h2 id="箭头函数的this会指向什么" tabindex="-1"><a class="header-anchor" href="#箭头函数的this会指向什么"><span>箭头函数的this会指向什么</span></a></h2><p>箭头函数this通常在创建的时候 就已经确定了指向，会指向外层的this</p><h2 id="以下this会指向什么" tabindex="-1"><a class="header-anchor" href="#以下this会指向什么"><span>以下this会指向什么</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token literal-property property">func</span><span class="token operator">:</span> fn
  <span class="token punctuation">}</span>
  obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="this会指向window-因为它声明的使用会指向外层的this" tabindex="-1"><a class="header-anchor" href="#this会指向window-因为它声明的使用会指向外层的this"><span>this会指向window，因为它声明的使用会指向外层的this</span></a></h4><p>如果箭头函数改成普通函数</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token literal-property property">func</span><span class="token operator">:</span> fn
  <span class="token punctuation">}</span>
  obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="此时还是指向obj函数会根据执行时-谁调用了它而指向谁" tabindex="-1"><a class="header-anchor" href="#此时还是指向obj函数会根据执行时-谁调用了它而指向谁"><span>此时还是指向obj函数会根据执行时，谁调用了它而指向谁</span></a></h4><p>如果箭头函数上加上bin，this会指向什么 依旧指向window，因为箭头函数不可改变this的指向</p><h2 id="var和let有什么区别" tabindex="-1"><a class="header-anchor" href="#var和let有什么区别"><span>var和let有什么区别</span></a></h2><ul><li>var和let 都有变量提升，但是let有一个暂时性死区</li><li>var 是函数作用域 let是块级作用域</li><li>var 可以重复声明，而let不行</li></ul><h2 id="es6-有哪些新的特性" tabindex="-1"><a class="header-anchor" href="#es6-有哪些新的特性"><span>ES6 有哪些新的特性</span></a></h2><ul><li>类class，extends</li><li>箭头函数</li><li>let const</li><li>模板字符串</li><li>扩展运算符...</li><li>解构赋值</li><li>import/export</li><li>Promise</li><li>Symbol</li><li>Proxy</li><li>函数参数默认值</li></ul><h2 id="json-parse和json-stringify的实现" tabindex="-1"><a class="header-anchor" href="#json-parse和json-stringify的实现"><span>Json.parse和Json.stringify的实现</span></a></h2><h5 id="json-stringify-是将对象或值转换为json字符串-json-parse-解析json-字符串-就是把json字符串转成对象" tabindex="-1"><a class="header-anchor" href="#json-stringify-是将对象或值转换为json字符串-json-parse-解析json-字符串-就是把json字符串转成对象"><span>json.stringify() 是将对象或值转换为JSON字符串 ; json.parse() 解析JSON 字符串，就是把JSON字符串转成对象</span></a></h5>`,25),u={href:"https://zhuanlan.zhihu.com/p/638767443",target:"_blank",rel:"noopener noreferrer"},d=s(`<h2 id="如何让你在数组中查找元素你会如何实现" tabindex="-1"><a class="header-anchor" href="#如何让你在数组中查找元素你会如何实现"><span>如何让你在数组中查找元素你会如何实现</span></a></h2><p>如果是基础类型的数组 考虑使用 indexOf进行查找 如果是对象数组 则使用findIndex进行查找</p><h2 id="call-apply-bind的区别" tabindex="-1"><a class="header-anchor" href="#call-apply-bind的区别"><span>call apply bind的区别</span></a></h2><ul><li><p>传递参数的方式 call 以参数列表形式传递参数 func.call(context, arg1, arg2, ...); apply 以数组形式传递参数 func.call(context, [arg1, arg2, ...]); bind 创建表一个新的函数，并以参数列表的形式传递参数，但不会立即执行原函数 const newFunc = func.bind(context,agr1,agr2,...)</p></li><li><p>立即执行和返回新函数 call/apply 立即执行原函数 bind 不会立即执行原函数，而是返回一个新函数，可以稍后调用</p></li><li><p>返回值 call/apply 返回原函数执行结果 const result = func.call(context, arg1, arg2, ...); bind 返回新函数，需要调用这个新函数才能获取结果 const newFunc = func.call(context, arg1, arg2, ...); const result = newFunc()</p></li><li><p>使用场景 call 和 apply 主要用于借用其他对象的方法，或者在一个对象上调用一个函数，同时指定该函数内部的 this 值。 bind： 主要用于创建一个与原函数拥有相同 this 值的新函数，方便稍后调用。</p></li><li><p>性能： call 和 apply由于立即执行原函数，可能略微更高效，但在大多数情况下性能差异微乎其微。 bind 创建了一个新的函数，性能可能稍差一些，但同样在大多数情况下不会引起明显的性能问题。</p></li></ul><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例：</span></a></h4><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code> <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">function</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token function">getValue</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 输出: 44</span>
 <span class="token function">getValue</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 输出: 44</span>

 <span class="token keyword">const</span> boundFunc <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">boundFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 输出: 44</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="new-string-123-和string-123-new-string-123-string-123-吗-typeof判断这两个是什么" tabindex="-1"><a class="header-anchor" href="#new-string-123-和string-123-new-string-123-string-123-吗-typeof判断这两个是什么"><span>new String(&#39;123&#39;)和String(&#39;123&#39;) new String(&#39;123&#39;)==String(&#39;123&#39;)吗，typeof判断这两个是什么</span></a></h2><pre><code>两种定义方式的不同
1.字符串常量存储在字符串常量池，目的是共享。
2.字符串非常量值对象存储在堆中。

 不相等
typeof(new String(&#39;123&#39;)) 为object typeof(&#39;123&#39;) string
</code></pre><h2 id="indexof-和-includes有什么区别" tabindex="-1"><a class="header-anchor" href="#indexof-和-includes有什么区别"><span>indexOf 和 includes有什么区别</span></a></h2><ul><li>indexOf是返回下标，如果找到返回对应下标如果没有则返回-1</li><li>includes返回值是true 和 false</li><li>indexOf 是严格等于 相当于（===），includes是使用零等值法 0可以等于-0 特别说明indexOf中NAN永远返回-1，而includes NAN可以是true</li></ul><h2 id="typeof-和instanceof的区别" tabindex="-1"><a class="header-anchor" href="#typeof-和instanceof的区别"><span>typeof 和instanceof的区别</span></a></h2><ul><li>都是用来判断变量是否为空，或者属于什么数据类型</li><li>typeof返回的是一个字符串，用来判断是什么数据类型</li><li>instanceof 返回的是一个布尔值，用来判断一个变量是否属于对象上的实例</li><li>typeof检测的是简单数据类型， instanceof 检测的是引用数据类型</li></ul><h2 id="js的数据类型" tabindex="-1"><a class="header-anchor" href="#js的数据类型"><span>js的数据类型</span></a></h2><ul><li>基本类型 Number、String、Boolean、Null、 Undefined、Symbol（ES6），BigInt（ES11）</li><li>引用类型 Object Function,Array</li></ul><h2 id="js的包装对象" tabindex="-1"><a class="header-anchor" href="#js的包装对象"><span>js的包装对象</span></a></h2><p>三种原始类型的值——(数值、字符串、布尔值 Number、String、Boolean) ——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 把原始类型的值变成（包装成）对象。</span>
<span class="token keyword">var</span> v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;abc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">typeof</span> v1 <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> v2 <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> v3 <span class="token comment">// &quot;object&quot;</span>

v1 <span class="token operator">===</span> <span class="token number">123</span> <span class="token comment">// false</span>
v2 <span class="token operator">===</span> <span class="token string">&#39;abc&#39;</span> <span class="token comment">// false</span>
v3 <span class="token operator">===</span> <span class="token boolean">true</span> <span class="token comment">// false</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Number、String和Boolean这三个原生对象，作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值；作为构造函数使用（带有new）时，可以将原始类型的值转为对象。</p><h2 id="浏览器的宏任务与微任务是什么" tabindex="-1"><a class="header-anchor" href="#浏览器的宏任务与微任务是什么"><span>浏览器的宏任务与微任务是什么</span></a></h2><p>微任务优先于宏任务</p><ul><li>宏任务 宏任务是由浏览器发起的任务，通常包括整体代码、setTimeout、setInterval、I/O 操作等。宏任务会被添加到宏任务队列中，等待浏览器的执行 宏任务执行完毕后，会清空微任务队列</li><li>微任务 微任务是在宏任务执行完毕后立即执行的任务。微任务通常包括 Promise 的回调、MutationObserver 等 微任务队列有自己的执行时机，在每个宏任务执行完毕后，会检查微任务队列并执行其中的所有任务。</li></ul><h2 id="堆和栈" tabindex="-1"><a class="header-anchor" href="#堆和栈"><span>堆和栈</span></a></h2><ul><li>堆（堆内存） 用于动态分配内区的区域，用于存储引用类型，如对象和数组 （在堆中分配的内存不会自动释放，需要通过垃圾回收机制来回收不再使用的内存。堆的大小通常比栈大，并且可以动态增长和收缩。）</li><li>栈 同于管理函数执行上下文和存储基本类型值的一种数据结构 （每当执行一个函数时，都会在栈中创建一个新的执行上下文，包括函数的参数、局部变量和函数的返回地址。当函数执行完成后， 对应的执行上下文会被销毁，栈会自动释放相关的内存。栈的大小通常比较小且固定，内存分配由系统自动管理。）</li></ul><p>区别 - 存储内容：堆用于存储引用类型的数据，如对象和数组；栈用于存储基本类型的数据，如布尔值、数值和字符串，以及函数执行的上下文。 - 分配方式：堆通过动态分配内存来存储数据；栈通过在执行上下文中的栈帧上分配固定大小的内存来存储数据。 - 大小和生长性：堆的大小通常比栈大，可以动态增长和收缩；栈的大小通常比较小且固定，由系统自动管理。 - 管理方式：堆的内存管理需要使用垃圾回收机制来回收不再使用的内存；栈的内存管理由系统自动处理，通过栈指针的移动来分配和释放内存。 - 生命周期：堆中分配的内存不会自动释放，需要通过垃圾回收来回收内存；栈中的内存由系统自动管理，在函数执行完成后自动释放。</p><h2 id="排序" tabindex="-1"><a class="header-anchor" href="#排序"><span>排序</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token comment">// 请将数组排序从小到大</span>
  <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">]</span>
  array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;排序后的数组&#39;</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="去重" tabindex="-1"><a class="header-anchor" href="#去重"><span>去重</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">===</span> index<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="扁平化" tabindex="-1"><a class="header-anchor" href="#扁平化"><span>扁平化</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序"><span>冒泡排序</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      a <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
      arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,32);function k(v,h){const a=t("ExternalLinkIcon");return p(),l("div",null,[r,n("p",null,[n("a",u,[o("具体答案：一文彻底弄懂JSON.parse()与JSON.stringify()"),i(a)])]),d])}const f=e(c,[["render",k],["__file","04.篇章4.html.vue"]]),g=JSON.parse(`{"path":"/posts/Study/04.%E7%AF%87%E7%AB%A04.html","title":"篇章4","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-03-28T08:00:00.000Z","category":["篇章4"],"tag":["js 基础 优化"],"star":true,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"for in 循环对象的时候是有序的吗","slug":"for-in-循环对象的时候是有序的吗","link":"#for-in-循环对象的时候是有序的吗","children":[]},{"level":2,"title":"前端做过哪些优化","slug":"前端做过哪些优化","link":"#前端做过哪些优化","children":[]},{"level":2,"title":"如何实现路由懒加载？","slug":"如何实现路由懒加载","link":"#如何实现路由懒加载","children":[]},{"level":2,"title":"箭头函数和普通函数的区别？","slug":"箭头函数和普通函数的区别","link":"#箭头函数和普通函数的区别","children":[]},{"level":2,"title":"箭头函数的this会指向什么","slug":"箭头函数的this会指向什么","link":"#箭头函数的this会指向什么","children":[]},{"level":2,"title":"以下this会指向什么","slug":"以下this会指向什么","link":"#以下this会指向什么","children":[]},{"level":2,"title":"var和let有什么区别","slug":"var和let有什么区别","link":"#var和let有什么区别","children":[]},{"level":2,"title":"ES6 有哪些新的特性","slug":"es6-有哪些新的特性","link":"#es6-有哪些新的特性","children":[]},{"level":2,"title":"Json.parse和Json.stringify的实现","slug":"json-parse和json-stringify的实现","link":"#json-parse和json-stringify的实现","children":[]},{"level":2,"title":"如何让你在数组中查找元素你会如何实现","slug":"如何让你在数组中查找元素你会如何实现","link":"#如何让你在数组中查找元素你会如何实现","children":[]},{"level":2,"title":"call apply bind的区别","slug":"call-apply-bind的区别","link":"#call-apply-bind的区别","children":[]},{"level":2,"title":"new String('123')和String('123') new String('123')==String('123')吗，typeof判断这两个是什么","slug":"new-string-123-和string-123-new-string-123-string-123-吗-typeof判断这两个是什么","link":"#new-string-123-和string-123-new-string-123-string-123-吗-typeof判断这两个是什么","children":[]},{"level":2,"title":"indexOf 和 includes有什么区别","slug":"indexof-和-includes有什么区别","link":"#indexof-和-includes有什么区别","children":[]},{"level":2,"title":"typeof 和instanceof的区别","slug":"typeof-和instanceof的区别","link":"#typeof-和instanceof的区别","children":[]},{"level":2,"title":"js的数据类型","slug":"js的数据类型","link":"#js的数据类型","children":[]},{"level":2,"title":"js的包装对象","slug":"js的包装对象","link":"#js的包装对象","children":[]},{"level":2,"title":"浏览器的宏任务与微任务是什么","slug":"浏览器的宏任务与微任务是什么","link":"#浏览器的宏任务与微任务是什么","children":[]},{"level":2,"title":"堆和栈","slug":"堆和栈","link":"#堆和栈","children":[]},{"level":2,"title":"排序","slug":"排序","link":"#排序","children":[]},{"level":2,"title":"去重","slug":"去重","link":"#去重","children":[]},{"level":2,"title":"扁平化","slug":"扁平化","link":"#扁平化","children":[]},{"level":2,"title":"冒泡排序","slug":"冒泡排序","link":"#冒泡排序","children":[]}],"git":{"createdTime":1711672807000,"updatedTime":1712027625000,"contributors":[{"name":"chengongtao","email":"chengongtao@unicheers.com","commits":6}]},"readingTime":{"minutes":7.77,"words":2331},"filePathRelative":"posts/Study/04.篇章4.md","localizedDate":"2024年3月28日"}`);export{f as comp,g as data};
