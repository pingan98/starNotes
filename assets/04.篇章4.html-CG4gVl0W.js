import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as p,c as o,a as n,b as l,d as i,f as s}from"./app-kbQ60-Vm.js";const c={},r=s(`<h1 id="篇章4" tabindex="-1"><a class="header-anchor" href="#篇章4"><span>篇章4</span></a></h1><h2 id="箭头函数和普通函数的区别" tabindex="-1"><a class="header-anchor" href="#箭头函数和普通函数的区别"><span>箭头函数和普通函数的区别？</span></a></h2><ul><li>箭头函数没有原型，所以箭头函数没有this</li><li>箭头函数this继承外层的第一个普通函数</li><li>不能直接修改箭头函数的this指向</li><li>箭头函数没有argements</li><li>箭头函数只能声明匿名函数（箭头函数可以通过表达式让箭头函数具名），普通函数可以是具名函数也可以是匿名函数</li></ul><h2 id="箭头函数的this会指向什么" tabindex="-1"><a class="header-anchor" href="#箭头函数的this会指向什么"><span>箭头函数的this会指向什么</span></a></h2><p>箭头函数this通常在创建的时候 就已经确定了指向，会指向外层的this</p><h2 id="以下this会指向什么" tabindex="-1"><a class="header-anchor" href="#以下this会指向什么"><span>以下this会指向什么</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token literal-property property">func</span><span class="token operator">:</span> fn
  <span class="token punctuation">}</span>
  obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="this会指向window-因为它声明的使用会指向外层的this" tabindex="-1"><a class="header-anchor" href="#this会指向window-因为它声明的使用会指向外层的this"><span>this会指向window，因为它声明的使用会指向外层的this</span></a></h4><p>如果箭头函数改成普通函数</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token literal-property property">func</span><span class="token operator">:</span> fn
  <span class="token punctuation">}</span>
  obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="此时还是指向obj函数会根据执行时-谁调用了它而指向谁" tabindex="-1"><a class="header-anchor" href="#此时还是指向obj函数会根据执行时-谁调用了它而指向谁"><span>此时还是指向obj函数会根据执行时，谁调用了它而指向谁</span></a></h4><p>如果箭头函数上加上bin，this会指向什么 依旧指向window，因为箭头函数不可改变this的指向</p><h2 id="var和let-const-有什么区别" tabindex="-1"><a class="header-anchor" href="#var和let-const-有什么区别"><span>var和let const 有什么区别</span></a></h2><ul><li>let和const是ES6新增的声明变量的关键词，之前声明变量的关键词是var。</li><li>作用域 let/const 声明变量具有块级作用域 只在声明代码块内有效；var声明的变量作用域可能受模块作用域影响</li><li>变量提升 var 声明变量存在变量提升，在声明前的代码访问不会报错但会得到undefined ；let/const 声明变量不会提升，如果声明前访问会抛出<code>ReferenceError</code> 错误</li><li>重复声明 var 声明的变量可以重复声明，后者覆盖前者； let/const 声明的不允许重复声明，会导致语法错误</li><li>赋值 var/let 声明的变量可以被重新赋值 const 声明的是常量 一旦赋值不可更改</li><li>与全局对象关联 var声明变量会与全局对象（window）关联，成为全局对象属性；let/const 声明的变量不会与全局对象关联</li></ul><h2 id="es6-有哪些新的特性" tabindex="-1"><a class="header-anchor" href="#es6-有哪些新的特性"><span>ES6 有哪些新的特性</span></a></h2><ul><li>类class，extends</li><li>箭头函数</li><li>let const</li><li>模板字符串</li><li>扩展运算符...</li><li>解构赋值</li><li>import/export</li><li>Promise</li><li>Symbol</li><li>Proxy</li><li>函数参数默认值</li></ul><h2 id="谈谈你对promise的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对promise的理解"><span>谈谈你对Promise的理解</span></a></h2><div class="hint-container info"><p class="hint-container-title">Promise</p><ul><li><p>1：Promise不仅是一个技术工具，它更代表了一种编程理念的体现， Promise作为一个构造函数，它可以生成具 有特定状态的实例，这些状态包括pending（等待）、resolved（成功）、rejected（失败），这种状态管理机制使得异步操作结果变的可预测和可控。</p></li><li><p>2：Promise即承诺，后续必要实现。一旦兑现则不可更改，因此Promise的状态只可修改一次</p></li><li><p>3：Promise是对回调函数的一种封装，它改进了异步编程的方式，传统的异步编程往往依赖回调函数，然后回调函数的嵌套过深很容易导致代码结构混乱，形成所谓的回调地狱问题。而Promise允许我们以同步的方式展示异步操作，从而简化代码臃肿以及可读性差的问题</p></li><li><p>4：Promise实例可以视为一个状态的展示器，我们可以利用Promise来管理具有状态改变的业务逻辑，结合 async function 进一步提升程序的清晰度和便捷性</p></li><li><p>5：Promise在前端技术体系有着非常广泛的的应用，比如Axios，fetch API等等，都采用了Promise对象来处理异步操作，因此熟练掌握和合理使用Promise是前端开发者必备的技能</p></li><li><p>6：当项目中存在多个异步操作，并且这些操作之间存在依赖关系时，Promise可以通过链式调用来处理这些操作，使得代码更加简洁和易读。比如在用户登录之后，我们需要根据用户信息去加载对应数据，这时我们可以使用Promise的链式调用，确保这些操作按照预期顺序执行，从而实现业务的连贯性和流畅性。</p></li><li><p>7： 尽管Promise解决了很多问题，但我们也不能滥用它，例如在使用Promise.all 时，一个失败可能全军覆没，这可能导致一个非关键性数据加载失败影响整个流程执行，因此在实际使用中，我们通常只在需要确保所有步骤完成后，才进行后续操作的场景下使用Promise.all，如图片的预加载功能，还有别嵌套太多不然代码就乱成一锅粥了</p></li></ul></div><h2 id="谈谈你对async的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对async的理解"><span>谈谈你对async的理解</span></a></h2><div class="hint-container info"><p class="hint-container-title">async await</p><p>async 函数是一个解决异步编程的方案，最好用的方案 本质上是generator语法糖 async 取代的是 * await 取代yield</p><ul><li>await 只会等promise对象 如果promise对象是pending状态就会一直等 如果promise对象是resolved状态就会执行后面的代码 如果promise对象是rejected状态就会退出当前async 函数</li><li>执行async函数返回值是一个promise对象 全部执行完就是resolved状态 内部promise对象是rejected状态或者内部报错了，就是rejected状态 代码还未执行完就是pending</li></ul></div><h2 id="json-parse和json-stringify的实现" tabindex="-1"><a class="header-anchor" href="#json-parse和json-stringify的实现"><span>Json.parse和Json.stringify的实现</span></a></h2><h5 id="json-stringify-是将对象或值转换为json字符串-json-parse-解析json-字符串-就是把json字符串转成对象" tabindex="-1"><a class="header-anchor" href="#json-stringify-是将对象或值转换为json字符串-json-parse-解析json-字符串-就是把json字符串转成对象"><span>json.stringify() 是将对象或值转换为JSON字符串 ; json.parse() 解析JSON 字符串，就是把JSON字符串转成对象</span></a></h5>`,22),u={href:"https://zhuanlan.zhihu.com/p/638767443",target:"_blank",rel:"noopener noreferrer"},d=s(`<h2 id="如何让你在数组中查找元素你会如何实现" tabindex="-1"><a class="header-anchor" href="#如何让你在数组中查找元素你会如何实现"><span>如何让你在数组中查找元素你会如何实现</span></a></h2><p>如果是基础类型的数组 考虑使用 indexOf进行查找 如果是对象数组 则使用findIndex进行查找</p><h2 id="call-apply-bind的区别" tabindex="-1"><a class="header-anchor" href="#call-apply-bind的区别"><span>call apply bind的区别</span></a></h2><ul><li><p>传递参数的方式 call 以参数列表形式传递参数 func.call(context, arg1, arg2, ...); apply 以数组形式传递参数 func.call(context, [arg1, arg2, ...]); bind 创建表一个新的函数，并以参数列表的形式传递参数，但不会立即执行原函数 const newFunc = func.bind(context,agr1,agr2,...)</p></li><li><p>立即执行和返回新函数 call/apply 立即执行原函数 bind 不会立即执行原函数，而是返回一个新函数，可以稍后调用</p></li><li><p>返回值 call/apply 返回原函数执行结果 const result = func.call(context, arg1, arg2, ...); bind 返回新函数，需要调用这个新函数才能获取结果 const newFunc = func.call(context, arg1, arg2, ...); const result = newFunc()</p></li><li><p>使用场景 call 和 apply 主要用于借用其他对象的方法，或者在一个对象上调用一个函数，同时指定该函数内部的 this 值。 bind： 主要用于创建一个与原函数拥有相同 this 值的新函数，方便稍后调用。</p></li><li><p>性能： call 和 apply由于立即执行原函数，可能略微更高效，但在大多数情况下性能差异微乎其微。 bind 创建了一个新的函数，性能可能稍差一些，但同样在大多数情况下不会引起明显的性能问题。</p></li></ul><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例：</span></a></h4><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code> <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">function</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token function">getValue</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 输出: 44</span>
 <span class="token function">getValue</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 输出: 44</span>

 <span class="token keyword">const</span> boundFunc <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">boundFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 输出: 44</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="new-string-123-和string-123-new-string-123-string-123-吗-typeof判断这两个是什么" tabindex="-1"><a class="header-anchor" href="#new-string-123-和string-123-new-string-123-string-123-吗-typeof判断这两个是什么"><span>new String(&#39;123&#39;)和String(&#39;123&#39;) new String(&#39;123&#39;)==String(&#39;123&#39;)吗，typeof判断这两个是什么</span></a></h2><pre><code>两种定义方式的不同
1.字符串常量存储在字符串常量池，目的是共享。
2.字符串非常量值对象存储在堆中。

 不相等
typeof(new String(&#39;123&#39;)) 为object typeof(&#39;123&#39;) string
</code></pre><h2 id="indexof-和-includes有什么区别" tabindex="-1"><a class="header-anchor" href="#indexof-和-includes有什么区别"><span>indexOf 和 includes有什么区别</span></a></h2><ul><li>indexOf是返回下标，如果找到返回对应下标如果没有则返回-1</li><li>includes返回值是true 和 false</li><li>indexOf 是严格等于 相当于（===），includes是使用零等值法 0可以等于-0 特别说明indexOf中NAN永远返回-1，而includes NAN可以是true</li></ul><h2 id="typeof-和instanceof的区别" tabindex="-1"><a class="header-anchor" href="#typeof-和instanceof的区别"><span>typeof 和instanceof的区别</span></a></h2><ul><li>都是用来判断变量是否为空，或者属于什么数据类型</li><li>typeof返回的是一个字符串，用来判断是什么数据类型</li><li>instanceof 返回的是一个布尔值，用来判断一个变量是否属于对象上的实例</li><li>typeof检测的是简单数据类型， instanceof 检测的是引用数据类型</li></ul><h2 id="js的数据类型" tabindex="-1"><a class="header-anchor" href="#js的数据类型"><span>js的数据类型</span></a></h2><ul><li>基本类型 Number、String、Boolean、Null、 Undefined、Symbol（ES6），BigInt（ES11）</li><li>引用类型 Object、Function、Array</li></ul><h2 id="js的包装对象" tabindex="-1"><a class="header-anchor" href="#js的包装对象"><span>js的包装对象</span></a></h2><p>三种原始类型的值——(数值、字符串、布尔值 Number、String、Boolean) ——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 把原始类型的值变成（包装成）对象。</span>
<span class="token keyword">var</span> v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;abc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">typeof</span> v1 <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> v2 <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> v3 <span class="token comment">// &quot;object&quot;</span>

v1 <span class="token operator">===</span> <span class="token number">123</span> <span class="token comment">// false</span>
v2 <span class="token operator">===</span> <span class="token string">&#39;abc&#39;</span> <span class="token comment">// false</span>
v3 <span class="token operator">===</span> <span class="token boolean">true</span> <span class="token comment">// false</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Number、String和Boolean这三个原生对象，作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值；作为构造函数使用（带有new）时，可以将原始类型的值转为对象。</p><h2 id="前端做过哪些优化" tabindex="-1"><a class="header-anchor" href="#前端做过哪些优化"><span>前端做过哪些优化</span></a></h2><ul><li>一些第三方库通过CDN方式引入</li><li>使用iconfont代替图片图标</li><li>图片懒加载 路由懒加载</li><li>代码层面例如防抖节流 频繁切换的场景使用v-show替换v-if</li><li>利用webpack-boundle-analyzer 分析打包后文件大小，进行优化</li></ul><h2 id="如何实现路由懒加载" tabindex="-1"><a class="header-anchor" href="#如何实现路由懒加载"><span>如何实现路由懒加载？</span></a></h2><p>在router 通过回调的方式引入组件就可以实现异步加载 原理： 主要是因为javascript 运行机制、事件循环以及打包工具的配合</p><ul><li>当打包工具遇到import的时候会把这些组件当做单独js文件进行打包</li><li>页面加载的时候，只有主要boundle会被下载</li><li>当用户需要组件的时候，再发起网络请求，请求对应的异步组件</li><li>然后进行下载和执行</li><li>最后渲染</li></ul><h2 id="字符串反转" tabindex="-1"><a class="header-anchor" href="#字符串反转"><span>字符串反转</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> newStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="排序" tabindex="-1"><a class="header-anchor" href="#排序"><span>排序</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  <span class="token comment">// 请将数组排序从小到大</span>
  <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">]</span>
  array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;排序后的数组&#39;</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="去重" tabindex="-1"><a class="header-anchor" href="#去重"><span>去重</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">===</span> index<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="扁平化" tabindex="-1"><a class="header-anchor" href="#扁平化"><span>扁平化</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序"><span>冒泡排序</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      a <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
      arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,33);function k(h,v){const a=t("ExternalLinkIcon");return p(),o("div",null,[r,n("p",null,[n("a",u,[l("具体答案：一文彻底弄懂JSON.parse()与JSON.stringify()"),i(a)])]),d])}const g=e(c,[["render",k],["__file","04.篇章4.html.vue"]]),f=JSON.parse(`{"path":"/posts/Study/04.%E7%AF%87%E7%AB%A04.html","title":"篇章4","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-03-28T08:00:00.000Z","category":["篇章4"],"tag":["js 数组 基础 优化"],"star":true,"description":"篇章4 箭头函数和普通函数的区别？ 箭头函数没有原型，所以箭头函数没有this 箭头函数this继承外层的第一个普通函数 不能直接修改箭头函数的this指向 箭头函数没有argements 箭头函数只能声明匿名函数（箭头函数可以通过表达式让箭头函数具名），普通函数可以是具名函数也可以是匿名函数 箭头函数的this会指向什么 箭头函数this通常在创建的...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/starNotes/posts/Study/04.%E7%AF%87%E7%AB%A04.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"篇章4"}],["meta",{"property":"og:description","content":"篇章4 箭头函数和普通函数的区别？ 箭头函数没有原型，所以箭头函数没有this 箭头函数this继承外层的第一个普通函数 不能直接修改箭头函数的this指向 箭头函数没有argements 箭头函数只能声明匿名函数（箭头函数可以通过表达式让箭头函数具名），普通函数可以是具名函数也可以是匿名函数 箭头函数的this会指向什么 箭头函数this通常在创建的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-02T08:21:41.000Z"}],["meta",{"property":"article:author","content":"平安"}],["meta",{"property":"article:tag","content":"js 数组 基础 优化"}],["meta",{"property":"article:published_time","content":"2024-03-28T08:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-02T08:21:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"篇章4\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-28T08:00:00.000Z\\",\\"dateModified\\":\\"2024-04-02T08:21:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"平安\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"箭头函数和普通函数的区别？","slug":"箭头函数和普通函数的区别","link":"#箭头函数和普通函数的区别","children":[]},{"level":2,"title":"箭头函数的this会指向什么","slug":"箭头函数的this会指向什么","link":"#箭头函数的this会指向什么","children":[]},{"level":2,"title":"以下this会指向什么","slug":"以下this会指向什么","link":"#以下this会指向什么","children":[]},{"level":2,"title":"var和let const 有什么区别","slug":"var和let-const-有什么区别","link":"#var和let-const-有什么区别","children":[]},{"level":2,"title":"ES6 有哪些新的特性","slug":"es6-有哪些新的特性","link":"#es6-有哪些新的特性","children":[]},{"level":2,"title":"谈谈你对Promise的理解","slug":"谈谈你对promise的理解","link":"#谈谈你对promise的理解","children":[]},{"level":2,"title":"谈谈你对async的理解","slug":"谈谈你对async的理解","link":"#谈谈你对async的理解","children":[]},{"level":2,"title":"Json.parse和Json.stringify的实现","slug":"json-parse和json-stringify的实现","link":"#json-parse和json-stringify的实现","children":[]},{"level":2,"title":"如何让你在数组中查找元素你会如何实现","slug":"如何让你在数组中查找元素你会如何实现","link":"#如何让你在数组中查找元素你会如何实现","children":[]},{"level":2,"title":"call apply bind的区别","slug":"call-apply-bind的区别","link":"#call-apply-bind的区别","children":[]},{"level":2,"title":"new String('123')和String('123') new String('123')==String('123')吗，typeof判断这两个是什么","slug":"new-string-123-和string-123-new-string-123-string-123-吗-typeof判断这两个是什么","link":"#new-string-123-和string-123-new-string-123-string-123-吗-typeof判断这两个是什么","children":[]},{"level":2,"title":"indexOf 和 includes有什么区别","slug":"indexof-和-includes有什么区别","link":"#indexof-和-includes有什么区别","children":[]},{"level":2,"title":"typeof 和instanceof的区别","slug":"typeof-和instanceof的区别","link":"#typeof-和instanceof的区别","children":[]},{"level":2,"title":"js的数据类型","slug":"js的数据类型","link":"#js的数据类型","children":[]},{"level":2,"title":"js的包装对象","slug":"js的包装对象","link":"#js的包装对象","children":[]},{"level":2,"title":"前端做过哪些优化","slug":"前端做过哪些优化","link":"#前端做过哪些优化","children":[]},{"level":2,"title":"如何实现路由懒加载？","slug":"如何实现路由懒加载","link":"#如何实现路由懒加载","children":[]},{"level":2,"title":"字符串反转","slug":"字符串反转","link":"#字符串反转","children":[]},{"level":2,"title":"排序","slug":"排序","link":"#排序","children":[]},{"level":2,"title":"去重","slug":"去重","link":"#去重","children":[]},{"level":2,"title":"扁平化","slug":"扁平化","link":"#扁平化","children":[]},{"level":2,"title":"冒泡排序","slug":"冒泡排序","link":"#冒泡排序","children":[]}],"git":{"createdTime":1711672807000,"updatedTime":1712046101000,"contributors":[{"name":"chengongtao","email":"chengongtao@unicheers.com","commits":9}]},"readingTime":{"minutes":8.8,"words":2641},"filePathRelative":"posts/Study/04.篇章4.md","localizedDate":"2024年3月28日","excerpt":"\\n<h2>箭头函数和普通函数的区别？</h2>\\n<ul>\\n<li>箭头函数没有原型，所以箭头函数没有this</li>\\n<li>箭头函数this继承外层的第一个普通函数</li>\\n<li>不能直接修改箭头函数的this指向</li>\\n<li>箭头函数没有argements</li>\\n<li>箭头函数只能声明匿名函数（箭头函数可以通过表达式让箭头函数具名），普通函数可以是具名函数也可以是匿名函数</li>\\n</ul>\\n<h2>箭头函数的this会指向什么</h2>\\n<p>箭头函数this通常在创建的时候 就已经确定了指向，会指向外层的this</p>\\n<h2>以下this会指向什么</h2>\\n<div class=\\"language-javascript\\" data-ext=\\"js\\" data-title=\\"js\\"><pre class=\\"language-javascript\\"><code>  <span class=\\"token keyword\\">const</span> <span class=\\"token function-variable function\\">fn</span> <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token operator\\">=&gt;</span><span class=\\"token punctuation\\">{</span>\\n    console<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">this</span><span class=\\"token punctuation\\">)</span>\\n  <span class=\\"token punctuation\\">}</span>\\n  <span class=\\"token keyword\\">const</span> obj <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">{</span>\\n   <span class=\\"token literal-property property\\">func</span><span class=\\"token operator\\">:</span> fn\\n  <span class=\\"token punctuation\\">}</span>\\n  obj<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">func</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n</code></pre></div>","autoDesc":true}`);export{g as comp,f as data};
